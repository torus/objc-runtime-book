# 2 章 オブジェクト

前の章でオブジェクトに対してメソッドを呼び出す様子を見ました。この章では新しくオブジェクトを作る方法を見ます。

## オブジェクトの生成

Objective-C におけるオブジェクトとは、Objective-C のやり方でメソッドを呼び出すことができるデータ型だと言えます。そしてオブジェクトとは**クラス**のインスタンスでもあります。

Objective-C では、クラスのインスタンスを生成するには次のように書きます：

```objc
NSString *str = [NSString stringWithUTF8String: "hello"];
```

これをオブジェクトに対するメソッド呼び出しの書き方にあてはめると、`NSString` という名前のオブジェクトにの `stringWithUTF8String:` というメソッドを呼んでいるように見えます。

Objective-C のリファレンスでは、`NSString` はクラスで、`stringWithUTF8String:` は**クラスメソッド**として扱われています。

これをランタイム API で書くと次のようになります：

```objc
id cls = objc_getClass("NSString");
SEL sel = sel_registerName("stringWithUTF8String:");
NSString *str = objc_msgSend(cls, sel, "hello");
```

1 行目にでてくる `objc_getClass` という関数は次のようにプロトタイプ宣言されています：

```objc
id objc_getClass(const char *name);
```

クラス名を C の文字列として受け取って、それに対応する**クラスオブジェクト**を返します。クラスオブジェクトとはクラスを表すオブジェクトです。この関数は実行時にクラスを探して、与えられた名前に該当するクラスが見つかればそれを返します。見つからなければ `nil` を返します。戻り値の `id` という型についてはこの後で説明します。

実行時にクラスを探すということは、コンパイルの時点、あるいはコードを書いている時点では、そのような名前のクラスが実際に存在するかどうか知らなくても良いということです。また、手元にそのクラスを宣言したヘッダファイルがなくても、実行時にそのクラスにアクセスできるということです。

コードの後半をみると、クラスメソッドの呼び出しは、実際にはクラスを表すオブジェクトに対するメソッド呼び出しであることがわかります。

ただ、少し注意してほしいのは、Objective-C ランタイムでは、クラスは何かある別のクラスのインスタンスではない、ということです。クラスはあくまでもクラスであって、それそのものはオブジェクトではありません。ただ、そのクラスを表すオブジェクトが存在するというだけです。


## id 型

上の例で `id` という型が出てきました。これは、Objective-C のオブジェクトならなんでもいいという型です。上の例ではクラスオブジェクトを代入していますが、他のクラスのオブジェクトを代入することもできます。

たとえば、次のように書いてもいいのです：

```objc
id str = objc_msgSend(cls, sel, "hello");
```

なお、`NSString*` などの型を明示する場合は `*` が必要ですが、`id` はそれ自体がポインタ型なので `id*` とする必要はありません。

前章で出て来た `SEL` と同様に `id` も値のように扱って良い型です。いやしかし実体はポインタなのだから、無効なポインタになる事もあると心配になるかもしれませんが、大丈夫です。`id` 型の変数にオブジェクトを代入するとオブジェクトの**リファレンスカウンタ**が増えるので、ポインタの指すオブジェクトがいつの間にか解放されていて無効なポインタとなることはないことが保証されています。このような Objective-C ランタイムに特有のメモリ管理について、詳しくは 4 章で説明します。


## プロパティ

インスタンスのプロパティとは、そのオブジェクトのメンバ変数のようなものです。たとえば、`button` というオブジェクトの `title` というプロパティに値を設定するには次のように書きます：

```objc
button.title = @"Push Me!";
```

これは、C の構造体のメンバ変数に値を代入するのによく似ています。しかし、Objective-C のオブジェクトは全てポインタ型だったことを思い出してください。C の場合は、構造体へのポインタを使ってメンバ変数にアクセスするには、`.` ではなく `->` という演算子を使います。

また、プロパティの値を設定するには、次のようにメソッド呼び出しを使うこともできます。

```objc
[button setTitle: @"Push Me!"];
```

`title` というプロパティに対して `setTitle:` という**セッタ**が定義されています。このように、プロパティ名の先頭の文字を大文字にして頭に `set`、お尻に `:` がついたメソッドが定義されるという約束になっています。

プロパティの値を読み出すには**ゲッタ**を呼び出します。このゲッタはプロパティ名と同じ名前のメソッドです。つまり、Objective-C で次の 2 行は同じことをします。

```objc
NSString *title = button.title;
NSString *title = [button title];
```

ランタイム API でプロパティにアクセスするには、通常のメソッド呼び出しと同様にゲッタやセッタのメソッドを呼び出すだけです。

セッタを呼び出すには次のようにします：

```objc
NSString *title = @"Push Me!";
SEL sel = sel_registerName("setTitle:");
objc_msgSend(button, sel, title);
```

そしてゲッタを呼び出すには次のようにします：

```objc
SEL sel = sel_registerName("title");
NSString *title = objc_msgSend(button, sel);
```

## NSObject

## アロケーションと初期化
